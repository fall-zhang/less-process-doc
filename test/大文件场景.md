## 基本文件上传和读取

### 方法 1：手动读取文件内容

go

```go
package main
import (
    "encoding/json"
    "github.com/gin-gonic/gin"
    "io/ioutil"
    "log"
)

type User struct {
    Name  string `json:"name"`
    Email string `json:"email"`
    Age   int    `json:"age"`
}

func main() {
    r := gin.Default()
    
    r.POST("/upload/json", func(c *gin.Context) {
        // 获取上传的文件
        file, err := c.FormFile("json_file")
        if err != nil {
            c.JSON(400, gin.H{"error": "请上传JSON文件", "details": err.Error()})
            return
        }
        
        // 打开文件
        uploadedFile, err := file.Open()
        if err != nil {
            c.JSON(500, gin.H{"error": "无法打开文件", "details": err.Error()})
            return
        }
        defer uploadedFile.Close()
        
        // 读取文件内容
        content, err := ioutil.ReadAll(uploadedFile)
        if err != nil {
            c.JSON(500, gin.H{"error": "无法读取文件内容", "details": err.Error()})
            return
        }
        
        // 解析 JSON
        var user User
        if err := json.Unmarshal(content, &user); err != nil {
            c.JSON(400, gin.H{"error": "JSON解析失败", "details": err.Error()})
            return
        }
        c.JSON(200, gin.H{
            "message":      "文件上传并解析成功",
            "filename":     file.Filename,
            "file_size":    file.Size,
            "parsed_data":  user,
         })
    })
    
    r.Run(":8080")
}
```

## 2. 使用 Gin 的 Binding 功能

### 方法 2：直接绑定 JSON 请求体

go

```go
type Config struct {
    Database struct {
        Host     string `json:"host" binding:"required"`
        Port     int    `json:"port" binding:"required"`
        Username string `json:"username"`
        Password string `json:"password"`
    } `json:"database"`
    
    Server struct {
        Port    int    `json:"port" binding:"required"`
        Timeout int    `json:"timeout"`
        Debug   bool   `json:"debug"`
    } `json:"server"`
}

func main() {
    r := gin.Default()
    
    r.POST("/config/upload", func(c *gin.Context) {
        var config Config
        
        // 使用 ShouldBindJSON 自动解析请求体中的 JSON
        if err := c.ShouldBindJSON(&config); err != nil {
            c.JSON(400, gin.H{
                "error":   "JSON解析失败",
                "details": err.Error(),
            })
            return
        }
        
        c.JSON(200, gin.H{
            "message": "配置解析成功",
            "config":  config,
        })
    })
    
    r.Run(":8080")
}
```

## 3. 处理多文件上传和 JSON 解析

### 方法 3：批量处理多个 JSON 文件

go

```
type Product struct {
    ID          int     `json:"id" binding:"required"`
    Name        string  `json:"name" binding:"required"`
    Price       float64 `json:"price" binding:"required"`
    Description string  `json:"description"`
    Category    string  `json:"category"`
}

func main() {
    r := gin.Default()
    
    r.POST("/products/batch-upload", func(c *gin.Context) {
        // 获取多文件上传
        form, err := c.MultipartForm()
        if err != nil {
            c.JSON(400, gin.H{"error": "请选择文件上传", "details": err.Error()})
            return
        }
        
        files := form.File["product_files"]
        if len(files) == 0 {
            c.JSON(400, gin.H{"error": "未找到上传文件"})
            return
        }
        
        var successfulProducts []Product
        var failedFiles []gin.H
        
        // 处理每个文件
        for _, file := range files {
            uploadedFile, err := file.Open()
            if err != nil {
                failedFiles = append(failedFiles, gin.H{
                    "filename": file.Filename,
                    "error":    "无法打开文件",
                })
                continue
            }
            
            content, err := ioutil.ReadAll(uploadedFile)
            uploadedFile.Close()
            
            if err != nil {
                failedFiles = append(failedFiles, gin.H{
                    "filename": file.Filename,
                    "error":    "无法读取文件内容",
                })
                continue
            }
            
            var product Product
            if err := json.Unmarshal(content, &product); err != nil {
                failedFiles = append(failedFiles, gin.H{
                    "filename": file.Filename,
                    "error":    "JSON解析失败: " + err.Error(),
                })
                continue
            }
            
            successfulProducts = append(successfulProducts, product)
        }
        
        c.JSON(200, gin.H{
            "message":             "批量处理完成",
            "successful_count":    len(successfulProducts),
            "failed_count":        len(failedFiles),
            "successful_products": successfulProducts,
            "failed_files":        failedFiles,
        })
    })
    
    r.Run(":8080")
}
```

## 4. 高级 JSON 处理技巧

### 方法 4：灵活的 JSON 解析

go

```
func main() {
    r := gin.Default()
    
    r.POST("/flexible/json", func(c *gin.Context) {
        // 方法1: 读取原始字节
        rawData, err := c.GetRawData()
        if err != nil {
            c.JSON(400, gin.H{"error": "无法读取请求体"})
            return
        }
        
        // 方法2: 先验证JSON格式
        if !json.Valid(rawData) {
            c.JSON(400, gin.H{"error": "无效的JSON格式"})
            return
        }
        
        // 方法3: 解析为map（适用于不确定结构的JSON）
        var jsonData map[string]interface{}
        if err := json.Unmarshal(rawData, &jsonData); err != nil {
            c.JSON(400, gin.H{"error": "JSON解析失败"})
            return
        }
        
        // 方法4: 根据类型动态处理
        response := gin.H{
            "raw_json":    string(rawData),
            "parsed_data": jsonData,
            "data_type":   "dynamic",
        }
        
        // 尝试识别特定结构
        if name, exists := jsonData["name"]; exists {
            response["identified_type"] = "可能为用户数据"
            response["name"] = name
        }
        
        c.JSON(200, response)
    })
    
    r.Run(":8080")
}
```

## 5. 完整的文件上传服务示例

go

```
package main

import (
    "encoding/json"
    "github.com/gin-gonic/gin"
    "io/ioutil"
    "net/http"
    "os"
    "path/filepath"
    "time"
)

type UploadResponse struct {
    Success   bool        `json:"success"`
    Message   string      `json:"message"`
    Data      interface{} `json:"data,omitempty"`
    Timestamp string      `json:"timestamp"`
}

type UserProfile struct {
    UserID      string    `json:"user_id" binding:"required"`
    FirstName   string    `json:"first_name" binding:"required"`
    LastName    string    `json:"last_name" binding:"required"`
    Email       string    `json:"email" binding:"required,email"`
    Phone       string    `json:"phone"`
    DateOfBirth time.Time `json:"date_of_birth"`
    Address     Address   `json:"address"`
}

type Address struct {
    Street  string `json:"street"`
    City    string `json:"city"`
    State   string `json:"state"`
    ZipCode string `json:"zip_code"`
    Country string `json:"country"`
}

func main() {
    r := gin.Default()
    
    // 创建上传目录
    uploadDir := "./uploads"
    os.MkdirAll(uploadDir, 0755)
    
    r.POST("/api/upload/profile", uploadUserProfile)
    r.POST("/api/upload/batch", uploadBatchFiles)
    r.POST("/api/upload/raw-json", uploadRawJSON)
    
    r.Run(":8080")
}

func uploadUserProfile(c *gin.Context) {
    var profile UserProfile
    
    // 方法1: 直接从请求体绑定JSON
    if err := c.ShouldBindJSON(&profile); err != nil {
        sendErrorResponse(c, http.StatusBadRequest, "JSON解析失败: "+err.Error())
        return
    }
    
    // 保存到文件（可选）
    saveProfileToFile(profile)
    
    sendSuccessResponse(c, "用户资料上传成功", profile)
}

func uploadBatchFiles(c *gin.Context) {
    form, err := c.MultipartForm()
    if err != nil {
        sendErrorResponse(c, http.StatusBadRequest, "请选择文件上传")
        return
    }
    
    files := form.File["files"]
    if len(files) == 0 {
        sendErrorResponse(c, http.StatusBadRequest, "未找到上传文件")
        return
    }
    
    var results []gin.H
    
    for _, file := range files {
        result := processUploadedFile(file)
        results = append(results, result)
    }
    
    sendSuccessResponse(c, "批量文件处理完成", results)
}

func uploadRawJSON(c *gin.Context) {
    // 读取原始请求体
    body, err := c.GetRawData()
    if err != nil {
        sendErrorResponse(c, http.StatusBadRequest, "无法读取请求体")
        return
    }
    
    // 验证JSON格式
    if !json.Valid(body) {
        sendErrorResponse(c, http.StatusBadRequest, "无效的JSON格式")
        return
    }
    
    // 解析JSON
    var jsonData interface{}
    if err := json.Unmarshal(body, &jsonData); err != nil {
        sendErrorResponse(c, http.StatusBadRequest, "JSON解析失败")
        return
    }
    
    sendSuccessResponse(c, "原始JSON处理成功", gin.H{
        "raw_length": len(body),
        "parsed":     jsonData,
    })
}

func processUploadedFile(file *multipart.FileHeader) gin.H {
    uploadedFile, err := file.Open()
    if err != nil {
        return gin.H{
            "filename": file.Filename,
            "status":   "failed",
            "error":    "无法打开文件",
        }
    }
    defer uploadedFile.Close()
    
    content, err := ioutil.ReadAll(uploadedFile)
    if err != nil {
        return gin.H{
            "filename": file.Filename,
            "status":   "failed",
            "error":    "无法读取文件",
        }
    }
    
    // 尝试解析为JSON
    var jsonData interface{}
    if err := json.Unmarshal(content, &jsonData); err != nil {
        return gin.H{
            "filename": file.Filename,
            "status":   "failed",
            "error":    "不是有效的JSON文件",
        }
    }
    
    // 保存文件
    filePath := filepath.Join("./uploads", file.Filename)
    if err := ioutil.WriteFile(filePath, content, 0644); err != nil {
        return gin.H{
            "filename": file.Filename,
            "status":   "partial",
            "error":    "文件保存失败",
            "data":     jsonData,
        }
    }
    
    return gin.H{
        "filename": file.Filename,
        "status":   "success",
        "data":     jsonData,
        "filepath": filePath,
    }
}

func saveProfileToFile(profile UserProfile) {
    data, _ := json.MarshalIndent(profile, "", "  ")
    filename := "profile_" + profile.UserID + "_" + time.Now().Format("20060102_150405") + ".json"
    ioutil.WriteFile(filepath.Join("./uploads", filename), data, 0644)
}

func sendSuccessResponse(c *gin.Context, message string, data interface{}) {
    c.JSON(http.StatusOK, UploadResponse{
        Success:   true,
        Message:   message,
        Data:      data,
        Timestamp: time.Now().Format(time.RFC3339),
    })
}

func sendErrorResponse(c *gin.Context, status int, message string) {
    c.JSON(status, UploadResponse{
        Success:   false,
        Message:   message,
        Timestamp: time.Now().Format(time.RFC3339),
    })
}
```

## 6. 测试和使用示例

### 使用 curl 测试：

bash

```
# 测试直接JSON上传
curl -X POST http://localhost:8080/api/upload/profile \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "12345",
    "first_name": "张",
    "last_name": "三",
    "email": "zhangsan@example.com",
    "phone": "13800138000",
    "date_of_birth": "1990-01-01T00:00:00Z",
    "address": {
      "street": "人民路100号",
      "city": "北京",
      "state": "北京",
      "zip_code": "100000",
      "country": "中国"
    }
  }'

# 测试文件上传
curl -X POST http://localhost:8080/api/upload/batch \
  -F "files=@/path/to/user1.json" \
  -F "files=@/path/to/user2.json"

# 测试原始JSON上传
curl -X POST http://localhost:8080/api/upload/raw-json \
  -H "Content-Type: application/json" \
  -d '{"any": "json", "structure": "will be", "accepted": true}'
```

## 7. 错误处理和验证增强

go

```
// 自定义JSON验证中间件
func JSONValidationMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 检查Content-Type
        contentType := c.GetHeader("Content-Type")
        if contentType != "application/json" {
            c.JSON(400, gin.H{"error": "Content-Type必须是application/json"})
            c.Abort()
            return
        }
        
        // 预读取并验证JSON
        body, err := c.GetRawData()
        if err != nil {
            c.JSON(400, gin.H{"error": "无法读取请求体"})
            c.Abort()
            return
        }
        
        // 重新设置Body以便后续读取
        c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(body))
        
        // 验证JSON格式
        if !json.Valid(body) {
            c.JSON(400, gin.H{"error": "无效的JSON格式"})
            c.Abort()
            return
        }
        
        c.Set("rawJSON", body)
        c.Next()
    }
}

// 使用中间件
r.Use(JSONValidationMiddleware())
```

这些方法涵盖了 Gin 框架中处理 JSON 文件上传和解析的所有常见场景，你可以根据具体需求选择合适的方法。